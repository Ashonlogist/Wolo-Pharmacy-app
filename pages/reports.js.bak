// Reports page functionality
const { ipcRenderer } = window.electron || {};
import { reports, products } from '../core/api.js';
import { showToast } from '../core/utils.js';

// Global variables
let chart1, chart2; // For Chart.js instances

// Initialize the reports page
document.addEventListener('DOMContentLoaded', async () => {
    try {
        initializeDatePickers();
        setupEventListeners();
        await loadReportCategories();
        
        // Set default dates
        const today = new Date();
        const lastMonth = new Date();
        lastMonth.setMonth(today.getMonth() - 1);
        
        document.getElementById('reportStartDate').valueAsDate = lastMonth;
        document.getElementById('reportEndDate').valueAsDate = today;
        
        // Initialize event listeners for report type changes
        document.getElementById('reportType').addEventListener('change', updateReportForm);
        
        // Add event listener for generate report button
        document.getElementById('generateReportBtn').addEventListener('click', generateReport);
        
        // Initialize the form
        updateReportForm();
        
    } catch (error) {
        console.error('Error initializing reports page:', error);
        showToast('Failed to initialize reports page', 'danger');
    }
});

// Initialize date pickers
function initializeDatePickers() {
    try {
        // This is now handled in the DOMContentLoaded event
        // to ensure elements are available
    } catch (error) {
        console.error('Error initializing date pickers:', error);
    }
}

// Set up event listeners
function setupEventListeners() {
    // Event delegation for export buttons
    document.addEventListener('click', (e) => {
        if (e.target.matches('#exportCsvBtn, #exportCsvBtn *')) {
            exportReport('csv');
        } else if (e.target.matches('#exportExcelBtn, #exportExcelBtn *')) {
            exportReport('excel');
        } else if (e.target.matches('#exportPdfBtn, #exportPdfBtn *, #exportPdfBtn2, #exportPdfBtn2 *')) {
            exportReport('pdf');
        } else if (e.target.matches('#printReportBtn, #printReportBtn *')) {
            window.print();
        }
    });
    
    // Form submission
    const reportForm = document.getElementById('reportForm');
    if (reportForm) {
        reportForm.addEventListener('submit', (e) => {
            e.preventDefault();
            generateReport();
        });
    }
}

// Load report categories
async function loadReportCategories() {
    try {
        const categorySelect = document.getElementById('reportCategory');
        if (!categorySelect) return;
        
        // Show loading state
        const originalHTML = categorySelect.innerHTML;
        categorySelect.innerHTML = '<option value="">Loading categories...</option>';
        
        try {
            const response = await products.getAll();
            const categories = response.data || [];
            
            // Clear existing options
            categorySelect.innerHTML = '<option value="">All Categories</option>';
            
            // Add categories to the dropdown
            categories.forEach(category => {
                if (category.category) { // Only add if category exists
                    const option = document.createElement('option');
                    option.value = category.category;
                    option.textContent = category.category;
                    categorySelect.appendChild(option);
                }
            });
            
            // Initialize Select2 for better UX
            if (window.$ && window.$.fn.select2) {
                $(categorySelect).select2({
                    placeholder: 'Select a category',
                    allowClear: true,
                    width: '100%'
                });
            }
            
            console.log('Categories loaded successfully:', categories);
        } catch (error) {
            console.error('Error fetching categories:', error);
            categorySelect.innerHTML = originalHTML;
            showToast('Failed to load categories', 'danger');
        }
    } catch (error) {
        console.error('Error in loadReportCategories:', error);
        showToast('Error loading categories', 'danger');
    }
}

// Update report form based on selected report type
function updateReportForm() {
    const reportType = document.getElementById('reportType')?.value;
    const categoryGroup = document.getElementById('categoryGroup');
    const dateRangeGroup = document.getElementById('dateRangeGroup');
    const lowStockGroup = document.getElementById('lowStockThresholdGroup');
    
    // Reset all groups
    categoryGroup.style.display = 'none';
    dateRangeGroup.style.display = 'none';
    lowStockGroup.style.display = 'none';
    
    // Show/hide form elements based on report type
    switch(reportType) {
        case 'sales':
            categoryGroup.style.display = 'block';
            dateRangeGroup.style.display = 'block';
            break;
            
        case 'inventory':
            categoryGroup.style.display = 'block';
            dateRangeGroup.style.display = 'block';
            break;
            
        case 'low-stock':
            categoryGroup.style.display = 'block';
            lowStockGroup.style.display = 'block';
            break;
            
        case 'expiring':
            categoryGroup.style.display = 'block';
            dateRangeGroup.style.display = 'block';
            break;
            
        default:
            // Default view
            break;
    }
    
    // Update the generate button text
    const generateBtn = document.getElementById('generateReportBtn');
    if (generateBtn) {
        generateBtn.textContent = `Generate ${reportType ? reportType.charAt(0).toUpperCase() + reportType.slice(1).replace('-', ' ') : 'Report'}`;
    }
}

// Validate date range
function validateDateRange() {
    try {
        const startDate = new Date(document.getElementById('reportStartDate').value);
        const endDate = new Date(document.getElementById('reportEndDate').value);
        
        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            return false; // Invalid date
        }
        
        if (startDate > endDate) {
            showToast('End date cannot be before start date', 'warning');
            document.getElementById('reportEndDate').value = '';
            return false;
        }
        
        return true;
    } catch (error) {
        console.error('Error validating date range:', error);
        return false;
    }
}

// Generate report
async function generateReport() {
    try {
        const reportType = document.getElementById('reportType')?.value;
        if (!reportType) {
            showToast('Please select a report type', 'warning');
            return;
        }

        // Show loading state
        const generateBtn = document.getElementById('generateReportBtn');
        const originalBtnText = generateBtn.innerHTML;
        generateBtn.disabled = true;
        generateBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Generating...';
        
        // Hide previous report
        document.getElementById('reportContainer').style.display = 'none';
        
        // Get form values
        const category = document.getElementById('reportCategory')?.value || '';
        const startDate = document.getElementById('reportStartDate')?.value || '';
        const endDate = document.getElementById('reportEndDate')?.value || '';
        const threshold = document.getElementById('lowStockThreshold')?.value || 10;
        
        // Validate dates if they're required
        if (['sales', 'inventory', 'expiring'].includes(reportType)) {
            if (!startDate || !endDate) {
                showToast('Please select a date range', 'warning');
                return;
            }
            if (!validateDateRange()) {
                return;
            }
        }
        
        try {
            let reportData;
            let reportTitle = '';
            
            // Call the appropriate API based on report type
            switch(reportType) {
                case 'sales':
                    reportTitle = 'Sales Report';
                    reportData = await reports.generateSalesReport({ 
                        startDate, 
                        endDate, 
                        category: category || null 
                    });
                    break;
                    
                case 'inventory':
                    reportTitle = 'Inventory Report';
                    reportData = await reports.generateInventoryReport({ 
                        category: category || null,
                        startDate,
                        endDate
                    });
                    break;
                    
                case 'low-stock':
                    reportTitle = 'Low Stock Report';
                    reportData = await reports.getLowStockItems(parseInt(threshold) || 10);
                    break;
                    
                case 'expiring':
                    reportTitle = 'Expiring Products';
                    reportData = await reports.getExpiringProducts({ 
                        category: category || null,
                        days: 30 // Default to next 30 days
                    });
                    break;
                    
                default:
                    throw new Error('Invalid report type');
            }
            
            // Update report title
            document.getElementById('reportTitle').textContent = reportTitle;
            document.getElementById('reportGeneratedDate').textContent = new Date().toLocaleString();
            
            // Render the report
            await renderReport(reportType, reportData);
            
            // Show the report container and summary
            document.getElementById('reportContainer').style.display = 'block';
            document.getElementById('reportSummary').style.display = 'flex';
            document.getElementById('exportButtons').style.display = 'flex';
            
            // Scroll to the report
            document.getElementById('reportContainer').scrollIntoView({ behavior: 'smooth' });
            
            showToast('Report generated successfully', 'success');
            
        } catch (error) {
            console.error('Error generating report:', error);
            showToast(`Failed to generate report: ${error.message || 'Unknown error'}`, 'danger');
        }
        
    } catch (error) {
        console.error('Error in generateReport:', error);
        showToast('An error occurred while generating the report', 'danger');
    } finally {
        // Restore button state
        const generateBtn = document.getElementById('generateReportBtn');
        if (generateBtn) {
            generateBtn.disabled = false;
            generateBtn.innerHTML = 'Generate Report';
        }
    }
}

// Render report based on type
async function renderReport(reportType, data) {
    try {
        // Clear previous report
        const tableHeader = document.getElementById('reportTableHeader');
        const tableBody = document.getElementById('reportTableBody');
        const tableFooter = document.getElementById('reportTableFooter');
        
        tableHeader.innerHTML = '';
        tableBody.innerHTML = '';
        tableFooter.innerHTML = '';
        
        // Call the appropriate render function based on report type
        switch(reportType) {
            case 'sales':
                await renderSalesReport(data);
                break;
            case 'inventory':
                await renderInventoryReport(data);
                break;
            case 'low-stock':
                await renderLowStockReport(data);
                break;
            case 'expiring':
                await renderExpiringProductsReport(data);
                break;
            default:
                throw new Error('Unsupported report type');
        }
        
        // Show the report container
        document.getElementById('reportContainer').style.display = 'block';
        
    } catch (error) {
        console.error('Error rendering report:', error);
        throw error;
    }
}

// Render inventory report
async function renderInventoryReport(data) {
    const tableHeader = document.getElementById('reportTableHeader');
    const tableBody = document.getElementById('reportTableBody');
    const tableFooter = document.getElementById('reportTableFooter');
    
    if (!tableHeader || !tableBody || !tableFooter) return;
    
    try {
        // Set up table headers
        tableHeader.innerHTML = `
            <tr>
                <th>Product</th>
                <th>Category</th>
                <th>SKU</th>
                <th>In Stock</th>
                <th>Price</th>
                <th>Value</th>
                <th>Status</th>
            </tr>
        `;
        
        // Add table rows
        let totalValue = 0;
        let totalItems = 0;
        let outOfStockCount = 0;
        let lowStockCount = 0;
        
        data.forEach(item => {
            const inStock = parseInt(item.quantityInStock) || 0;
            const price = parseFloat(item.sellingPrice) || 0;
            const value = inStock * price;
            
            // Update counts
            totalValue += value;
            totalItems += inStock;
            
            if (inStock === 0) outOfStockCount++;
            else if (inStock <= (parseInt(item.reorderLevel) || 5)) lowStockCount++;
            
            const statusClass = inStock === 0 ? 'bg-danger' : 
                              inStock <= (parseInt(item.reorderLevel) || 5) ? 'bg-warning' : 'bg-success';
            
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${item.name || 'N/A'}</td>
                <td>${item.category || 'Uncategorized'}</td>
                <td>${item.sku || 'N/A'}</td>
                <td>${inStock}</td>
                <td>GH₵ ${price.toFixed(2)}</td>
                <td>GH₵ ${value.toFixed(2)}</td>
                <td><span class="badge ${statusClass}">
                    ${inStock === 0 ? 'Out of Stock' : inStock <= (parseInt(item.reorderLevel) || 5) ? 'Low Stock' : 'In Stock'}
                </span></td>
            `;
            tableBody.appendChild(row);
        });
        
        // Add footer with totals
        tableFooter.innerHTML = `
            <tr class="table-active">
                <td colspan="3" class="text-end"><strong>Total:</strong></td>
                <td><strong>${totalItems} items</strong></td>
                <td></td>
                <td><strong>GH₵ ${totalValue.toFixed(2)}</strong></td>
                <td></td>
            </tr>
        `;
        
        // Update summary cards
        updateSummaryCards({
            totalProducts: data.length,
            totalInStock: totalItems,
            totalLowStock: lowStockCount,
            totalOutOfStock: outOfStockCount,
            totalValue: totalValue
        });
        
    } catch (error) {
        console.error('Error rendering inventory report:', error);
        throw error;
    }
}

// Render low stock report
async function renderLowStockReport(data) {
    // Sort by quantity ascending
    data.sort((a, b) => (parseInt(a.quantityInStock) || 0) - (parseInt(b.quantityInStock) || 0));
    
    const tableHeader = document.getElementById('reportTableHeader');
    const tableBody = document.getElementById('reportTableBody');
    const tableFooter = document.getElementById('reportTableFooter');
    
    if (!tableHeader || !tableBody || !tableFooter) return;
    
    try {
        // Set up table headers
        tableHeader.innerHTML = `
            <tr>
                <th>Product</th>
                <th>Category</th>
                <th>SKU</th>
                <th>In Stock</th>
                <th>Reorder Level</th>
                <th>Status</th>
                <th>Action</th>
            </tr>
        `;
        
        // Add table rows
        data.forEach(item => {
            const inStock = parseInt(item.quantityInStock) || 0;
            const reorderLevel = parseInt(item.reorderLevel) || 5;
            const statusClass = inStock === 0 ? 'bg-danger' : 'bg-warning';
            
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${item.name || 'N/A'}</td>
                <td>${item.category || 'Uncategorized'}</td>
                <td>${item.sku || 'N/A'}</td>
                <td>${inStock}</td>
                <td>${reorderLevel}</td>
                <td><span class="badge ${statusClass}">
                    ${inStock === 0 ? 'Out of Stock' : 'Low Stock'}
                </span></td>
                <td>
                    <button class="btn btn-sm btn-outline-primary" 
                            onclick="navigateTo('product-form', { id: '${item.id}' })">
                        Reorder
                    </button>
                </td>
            `;
            tableBody.appendChild(row);
        });
        
        // Add footer with counts
        tableFooter.innerHTML = `
            <tr class="table-active">
                <td colspan="7" class="text-end">
                    <strong>Total Low/Out of Stock Items: ${data.length}</strong>
                </td>
            </tr>
        `;
        
        // Update summary cards
        updateSummaryCards({
            totalProducts: data.length,
            totalLowStock: data.filter(item => (parseInt(item.quantityInStock) || 0) > 0).length,
            totalOutOfStock: data.filter(item => (parseInt(item.quantityInStock) || 0) === 0).length
        });
        
    } catch (error) {
        console.error('Error rendering low stock report:', error);
        throw error;
    }
}

// Render expiring products report
async function renderExpiringProductsReport(data) {
    // Sort by expiry date ascending
    data.sort((a, b) => new Date(a.expiryDate) - new Date(b.expiryDate));
    
    const tableHeader = document.getElementById('reportTableHeader');
    const tableBody = document.getElementById('reportTableBody');
    const tableFooter = document.getElementById('reportTableFooter');
    
    if (!tableHeader || !tableBody || !tableFooter) return;
    
    try {
        // Set up table headers
        tableHeader.innerHTML = `
            <tr>
                <th>Product</th>
                <th>Batch/Lot</th>
                <th>Expiry Date</th>
                <th>Days Until Expiry</th>
                <th>In Stock</th>
                <th>Status</th>
            </tr>
        `;
        
        // Add table rows
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        data.forEach(item => {
            const expiryDate = new Date(item.expiryDate);
            const timeDiff = expiryDate - today;
            const daysUntilExpiry = Math.ceil(timeDiff / (1000 * 60 * 60 * 24));
            
            let statusClass = 'bg-success';
            let statusText = 'Good';
            
            if (daysUntilExpiry <= 0) {
                statusClass = 'bg-danger';
                statusText = 'Expired';
            } else if (daysUntilExpiry <= 30) {
                statusClass = 'bg-warning';
                statusText = 'Expiring Soon';
            }
            
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${item.productName || 'N/A'}</td>
                <td>${item.batchNumber || 'N/A'}</td>
                <td>${expiryDate.toLocaleDateString()}</td>
                <td>${daysUntilExpiry} days</td>
                <td>${item.quantityInStock || 0}</td>
                <td><span class="badge ${statusClass}">${statusText}</span></td>
            `;
            tableBody.appendChild(row);
        });
        
        // Add footer with counts
        const expiredCount = data.filter(item => {
            const expiryDate = new Date(item.expiryDate);
            return expiryDate < today;
        }).length;
        
        const expiringSoonCount = data.filter(item => {
            const expiryDate = new Date(item.expiryDate);
            const timeDiff = expiryDate - today;
            const daysUntilExpiry = Math.ceil(timeDiff / (1000 * 60 * 60 * 24));
            return daysUntilExpiry > 0 && daysUntilExpiry <= 30;
        }).length;
        
        tableFooter.innerHTML = `
            <tr class="table-active">
                <td colspan="6" class="text-end">
                    <strong>Total: ${data.length} items (${expiredCount} expired, ${expiringSoonCount} expiring soon)</strong>
                </td>
            </tr>
        `;
        
        // Update summary cards
        updateSummaryCards({
            totalProducts: data.length,
            totalExpired: expiredCount,
            totalExpiringSoon: expiringSoonCount
        });
        
    } catch (error) {
        console.error('Error rendering expiring products report:', error);
        throw error;
    }
}

// Update summary cards with report data
function updateSummaryCards(stats = {}) {
    try {
        const {
            totalProducts = 0,
            totalInStock = 0,
            totalLowStock = 0,
            totalOutOfStock = 0,
            totalSales = 0,
            totalValue = 0,
            totalExpired = 0,
            totalExpiringSoon = 0
        } = stats;
        
        // Update summary cards if they exist
        const updateIfExists = (id, value, isCurrency = false) => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = isCurrency ? `GH₵ ${parseFloat(value || 0).toFixed(2)}` : (value || 0);
            }
        };
        
        updateIfExists('totalProducts', totalProducts);
        updateIfExists('totalInStock', totalInStock);
        updateIfExists('totalLowStock', totalLowStock);
        updateIfExists('totalOutOfStock', totalOutOfStock);
        updateIfExists('totalSales', totalSales, true);
        updateIfExists('totalInventoryValue', totalValue, true);
        
        // Show/hide summary section based on available data
        const summarySection = document.getElementById('reportSummary');
        if (summarySection) {
            summarySection.style.display = 'flex';
        }
        
        // Show/hide charts section
        const chartsSection = document.getElementById('reportCharts');
        if (chartsSection) {
            chartsSection.style.display = 'flex';
            
            // Initialize or update charts if Chart.js is available
            if (window.Chart) {
                updateCharts(stats);
            }
        }
        
    } catch (error) {
        console.error('Error updating summary cards:', error);
    }
}

// Update charts with report data
function updateCharts(stats = {}) {
    try {
        // Destroy existing charts if they exist
        if (chart1) chart1.destroy();
        if (chart2) chart2.destroy();
        
        // Get chart canvases
        const ctx1 = document.getElementById('inventoryByCategoryChart')?.getContext('2d');
        const ctx2 = document.getElementById('stockStatusChart')?.getContext('2d');
        
        if (!ctx1 || !ctx2) return;
        
        // Example chart 1: Inventory by Category (Pie chart)
        chart1 = new Chart(ctx1, {
            type: 'pie',
            data: {
                labels: ['Medicines', 'Supplements', 'Personal Care', 'First Aid', 'Other'],
                datasets: [{
                    data: [25, 20, 15, 10, 5], // Example data - replace with actual data
                    backgroundColor: [
                        '#4e73df',
                        '#1cc88a',
                        '#36b9cc',
                        '#f6c23e',
                        '#e74a3b'
                    ],
                    hoverBackgroundColor: [
                        '#2e59d9',
                        '#17a673',
                        '#2c9faf',
                        '#dda20a',
                        '#be2617'
                    ],
                    hoverBorderColor: 'rgba(234, 236, 244, 1)',
                }]
            },
            options: {
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                    },
                    title: {
                        display: true,
                        text: 'Inventory by Category'
                    }
                }
            }
        });
        
        // Example chart 2: Stock Status (Doughnut chart)
        chart2 = new Chart(ctx2, {
            type: 'doughnut',
            data: {
                labels: ['In Stock', 'Low Stock', 'Out of Stock'],
                datasets: [{
                    data: [
                        stats.totalInStock || 0,
                        stats.totalLowStock || 0,
                        stats.totalOutOfStock || 0
                    ],
                    backgroundColor: ['#1cc88a', '#f6c23e', '#e74a3b'],
                    hoverBackgroundColor: ['#17a673', '#dda20a', '#be2617'],
                    hoverBorderColor: 'rgba(234, 236, 244, 1)',
                }]
            },
            options: {
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                    },
                    title: {
                        display: true,
                        text: 'Stock Status'
                    }
                },
                cutout: '70%',
            }
        });
        
    } catch (error) {
        console.error('Error updating charts:', error);
    }
}

// Export report to different formats
async function exportReport(format = 'pdf') {
    try {
        const reportType = document.getElementById('reportType')?.value;
        if (!reportType) {
            showToast('Please generate a report first', 'warning');
            return;
        }
        
        // Show loading state
        const exportBtn = document.querySelector(`#export${format.toUpperCase()}Btn`);
        if (exportBtn) {
            const originalText = exportBtn.innerHTML;
            exportBtn.disabled = true;
            exportBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Exporting...';
            
            // Simulate export (replace with actual export logic)
            setTimeout(() => {
                // Reset button
                exportBtn.disabled = false;
                exportBtn.innerHTML = originalText;
                
                // Show success message
                showToast(`Report exported as ${format.toUpperCase()} successfully`, 'success');
            }, 1500);
            
            // TODO: Implement actual export logic based on format
            // This is a placeholder that would be replaced with actual export functionality
            console.log(`Exporting ${reportType} report as ${format}`);
            
        }
    } catch (error) {
        console.error('Error exporting report:', error);
        showToast(`Failed to export report: ${error.message || 'Unknown error'}`, 'danger');
    }
}
// Chart instances
let chart1 = null;
let chart2 = null;
                    <tr>
                        <th>Date</th>
                        <th>Invoice #</th>
                        <th>Customer</th>
                        <th class="text-end">Items</th>
                        <th class="text-end">Total</th>
                    </tr>
                </thead>
                <tbody>
    `;
    
    // Add rows
    data.forEach(sale => {
        html += `
            <tr>
                <td>${new Date(sale.date).toLocaleDateString()}</td>
                <td>${sale.invoiceNumber || '-'}</td>
                <td>${sale.customerName || 'Walk-in'}</td>
                <td class="text-end">${sale.items?.length || 0}</td>
                <td class="text-end">$${(sale.total || 0).toFixed(2)}</td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
            </table>
        </div>
    `;
    
    container.innerHTML = html;
}

// Render inventory report
function renderInventoryReport(data) {
    const container = document.getElementById('reportContent');
    if (!container) return;
    
    // Calculate totals
    const totalValue = data.reduce((sum, item) => sum + (item.quantityInStock * item.costPrice || 0), 0);
    const totalItems = data.reduce((sum, item) => sum + (item.quantityInStock || 0), 0);
    
    // Generate HTML
    let html = `
        <div class="report-header">
            <h3>Inventory Report</h3>
            <p>Date: ${new Date().toLocaleDateString()}</p>
            <div class="row mt-3 mb-4">
                <div class="col-md-6">
                    <div class="card bg-light">
                        <div class="card-body">
                            <h5 class="card-title">Total Inventory Value</h5>
                            <p class="h3 text-primary">$${totalValue.toFixed(2)}</p>
                        </div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card bg-light">
                        <div class="card-body">
                            <h5 class="card-title">Total Items in Stock</h5>
                            <p class="h3 text-success">${totalItems}</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="table-responsive">
            <table class="table table-striped table-hover">
                <thead class="table-dark">
                    <tr>
                        <th>Product</th>
                        <th>Category</th>
                        <th class="text-end">In Stock</th>
                        <th class="text-end">Cost Price</th>
                        <th class="text-end">Selling Price</th>
                        <th class="text-end">Value</th>
                    </tr>
                </thead>
                <tbody>
    `;
    
    // Add rows
    data.forEach(item => {
        const value = (item.quantityInStock || 0) * (item.costPrice || 0);
        html += `
            <tr>
                <td>${item.name}</td>
                <td>${item.category || '-'}</td>
                <td class="text-end">${item.quantityInStock || 0} ${item.unit || ''}</td>
                <td class="text-end">$${(item.costPrice || 0).toFixed(2)}</td>
                <td class="text-end">$${(item.sellingPrice || 0).toFixed(2)}</td>
                <td class="text-end">$${value.toFixed(2)}</td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
            </table>
        </div>
    `;
    
    container.innerHTML = html;
}

// Render low stock report
function renderLowStockReport(data) {
    const container = document.getElementById('reportContent');
    if (!container) return;
    
    // Generate HTML
    let html = `
        <div class="report-header">
            <h3>Low Stock Report</h3>
            <p>Generated on: ${new Date().toLocaleDateString()}</p>
            <div class="alert alert-warning">
                <i class="bi bi-exclamation-triangle"></i> 
                ${data.length} items are below the reorder level
            </div>
        </div>
        <div class="table-responsive">
            <table class="table table-striped table-hover">
                <thead class="table-dark">
                    <tr>
                        <th>Product</th>
                        <th>Category</th>
                        <th class="text-end">In Stock</th>
                        <th class="text-end">Reorder Level</th>
                        <th class="text-end">Needed</th>
                        <th class="text-end">Last Ordered</th>
                    </tr>
                </thead>
                <tbody>
    `;
    
    // Add rows
    data.forEach(item => {
        const needed = Math.max(0, (item.reorderLevel || 0) - (item.quantityInStock || 0));
        const lastOrdered = item.lastOrderedDate ? new Date(item.lastOrderedDate).toLocaleDateString() : 'Never';
        
        html += `
            <tr>
                <td>${item.name}</td>
                <td>${item.category || '-'}</td>
                <td class="text-end">${item.quantityInStock || 0} ${item.unit || ''}</td>
                <td class="text-end">${item.reorderLevel || 0}</td>
                <td class="text-end text-danger fw-bold">${needed}</td>
                <td class="text-end">${lastOrdered}</td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
            </table>
        </div>
    `;
    
    container.innerHTML = html;
}

// Render expiring products report
function renderExpiringProductsReport(data) {
    const container = document.getElementById('reportContent');
    if (!container) return;
    
    // Generate HTML
    let html = `
        <div class="report-header">
            <h3>Expiring Products Report</h3>
            <p>Products expiring in the next 30 days (as of ${new Date().toLocaleDateString()})</p>
            ${data.length === 0 ? '<div class="alert alert-success">No products are expiring soon.</div>' : ''}
        </div>
    `;
    
    if (data.length > 0) {
        html += `
            <div class="table-responsive">
                <table class="table table-striped table-hover">
                    <thead class="table-dark">
                        <tr>
                            <th>Product</th>
                            <th>Batch #</th>
                            <th class="text-end">Quantity</th>
                            <th class="text-end">Expiry Date</th>
                            <th class="text-end">Days Left</th>
                            <th class="text-end">Value</th>
                        </tr>
                    </thead>
                    <tbody>
        `;
        
        // Add rows
        data.forEach(item => {
            const expiryDate = new Date(item.expiryDate);
            const today = new Date();
            const daysLeft = Math.ceil((expiryDate - today) / (1000 * 60 * 60 * 24));
            const value = (item.quantityInStock || 0) * (item.costPrice || 0);
            
            let rowClass = '';
            if (daysLeft <= 7) rowClass = 'table-danger';
            else if (daysLeft <= 30) rowClass = 'table-warning';
            
            html += `
                <tr class="${rowClass}">
                    <td>${item.name}</td>
                    <td>${item.batchNumber || '-'}</td>
                    <td class="text-end">${item.quantityInStock || 0} ${item.unit || ''}</td>
                    <td class="text-end">${expiryDate.toLocaleDateString()}</td>
                    <td class="text-end">${daysLeft} days</td>
                    <td class="text-end">$${value.toFixed(2)}</td>
                </tr>
            `;
        });
        
        html += `
                    </tbody>
                </table>
            </div>
        `;
    }
    
    container.innerHTML = html;
}

// Export report to PDF
async function exportReport() {
    try {
        const reportType = document.getElementById('reportType')?.value;
        if (!reportType) {
            showToast('Please generate a report first', 'warning');
            return;
        }
        
        const reportTitle = document.querySelector('#reportContent h3')?.textContent || 'Report';
        
        // Get the report content
        const reportContent = document.getElementById('reportContent').innerHTML;
        
        // Generate PDF using the main process
        await ipcRenderer.invoke('export-to-pdf', {
            title: reportTitle,
            content: reportContent
        });
        
        showToast('Report exported to PDF successfully', 'success');
    } catch (error) {
        console.error('Error exporting report:', error);
        showToast('Failed to export report', 'danger');
    }
}

// Export sales to Excel
async function exportSalesToExcel() {
    try {
        const startDate = document.getElementById('reportStartDate')?.value || '';
        const endDate = document.getElementById('reportEndDate')?.value || '';
        const category = document.getElementById('reportCategory')?.value || '';
        
        console.log('Attempting to export sales to Excel with params:', { startDate, endDate, category });
        
        if (window.electron && window.electron.ipcRenderer) {
            try {
                // First, let the user choose the save location
                const savePath = await window.electron.ipcRenderer.invoke('show-save-dialog', {
                    title: 'Save Sales Export As',
                    defaultPath: 'sales_export.xlsx',
                    filters: [
                        { name: 'Excel Files', extensions: ['xlsx'] },
                        { name: 'All Files', extensions: ['*'] }
                    ]
                });

                if (!savePath.canceled && savePath.filePath) {
                    const result = await window.electron.ipcRenderer.invoke('export-sales-excel', { 
                        startDate, 
                        endDate, 
                        category: category || null,
                        filePath: savePath.filePath // Pass the selected file path
                    });
                    
                    console.log('Export result:', result);
                    showToast(`Sales data exported to ${result.filePath}`, 'success');
                } else {
                    console.log('Export cancelled by user');
                    return; // User cancelled the save dialog
                }
            } catch (error) {
                console.error('Error in export-sales-excel:', error);
                throw error;
            }
        } else {
            // Fallback for browser environment or when electron is not available
            console.warn('Electron IPC not available, using browser fallback');
            showToast('Export functionality is not available in the browser', 'warning');
        }
    } catch (error) {
        console.error('Error exporting sales to Excel:', error);
        showToast('Failed to export sales data: ' + (error.message || 'Unknown error'), 'danger');
    }
}

// Export products to Excel
async function exportProductsToExcel() {
    try {
        const category = document.getElementById('reportCategory')?.value || '';
        
        await ipcRenderer.invoke('export-products-excel', { 
            category: category || null 
        });
        
        showToast('Products data exported to Excel', 'success');
    } catch (error) {
        console.error('Error exporting products to Excel:', error);
        showToast('Failed to export products data', 'danger');
    }
}

// Export functions that need to be available to other modules
export {
    updateReportForm,
    validateDateRange,
    generateReport,
    exportSalesToExcel,
    exportReport,
    exportProductsToExcel
};
